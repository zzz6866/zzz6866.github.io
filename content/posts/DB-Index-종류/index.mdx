---
title: "DB 인덱스 종류"
date: 2021-04-10
slug: "/DB-인덱스-종류"
tags:
- Database
---

### B-tree
- 트리 구조로 저장되는 인덱스이다.
- 데이터베이스 인덱스로 가장 많이 사용된다.(암묵적 기본값)
- 알고리즘으로서는 뛰어난 성능은 아니지만 균형이 잘 잡혀있어 많이 사용된다.
- B+tree라는 B-tree의 수정 버전을 사용한다. B-tree 보다 효율적으로 검색이 가능한 알고리즘이다.(파일시스템에서도 사용 된다.)
- B+tree 성능이 좋은 이유
    1. 루프와 리프의 거리를 일정하게 유지하려고 한다.(검색 성능이 안정적)
    1. 데이터 정렬 상태를 유지하여 이진 탐색으로 검색 비용을 크게 줄인다.
    1. 데이터 정렬이 되어있기 때문에 집약 함수 등에서 요구되는 정렬을 하지 않아도 된다.

### 비트맵 인덱스
- 비트 플래그로 변환하여 저장하는 인덱스이다. 카디널리티가 낮은 필드에 효과가 좋다.
- 갱신시 오버헤드가 크기 때문에 빈번한 갱신이 일어나지 않게 사용하여야 한다.

### 해시 인덱스
- 해시 분산하여 등가 검색을 고속으로 실행하는 인덱스이다.
- 등가 검색 외에는 효과가 미비하다.
- 지원하는 구현도 적다.

### 인덱스 작성 기준
- 카디널리티 : 값의 균형.  
  높아야 좋다(중복도가 낮다) => 평균치에서 많이 흩어져있을수록 좋다.
- 선택률 : 특정 필드에 대해 테이블 전체에서 몇 개의 레코드가 선택되는지를 나타내는 개념이다.  
  낮아야 좋다 => 한 번의 선택으로 레코드가 조금만 선택되는 것이 좋은 것이다. 
- 클러스터링 팩터 : 인덱스의 성능을 결정하는 요소.  
  저장소에 같은 값이 어느 정도 물리적으로 뭉쳐 존재하는지 나타내느 지표.  
  높을수록 분산, 낮을수록 뭉쳐 있는 것을 뜻한다.

### 인덱스 성능 개선이 어려운 이유
- 규모가 커질수록 성능 보장이 어렵다.
- 검색 조건과 결합 조건을 기준으로 데이터를 효율적으로 압축할 수 있는 조건을 찾아야한다.(SQL 구문과 검색 키 필드의 카디널리티를 파악해야 한다.)


### 인덱스를 사용하지 않는 검색 조건
- LIKE 연산자  
  전방일치('{value}%')에만 적용이 가능하고, 중간일치('%{value}%')나 후방일치전방일치('%{value}')는 인덱스를 사용할 수 없다.
- 색인 필드의 연산  
  가능 : col1 > {value} * 100  
  불가능 : col1 / 100 > {value}, LENGTH(col1) > {value}
- IS NULL : 색인 필드 데이터에는 NULL 이 존재하지 않는다.
- 부정형 연산자(<>, !=, NOT IN)
